module sp_mod

    !*****************************************************************************************************************
    !
    !  OVERVIEW
    !
    ! The sp module defines all properties and procedures
    ! associated to stellar populations
    ! This structure allows to "follow" stellar evoltion process
    !    age/metalicity and build stellar population spectra
    !
    !*****************************************************************************************************************

    use parameters  ! Acces to global defintions and properties
    use model_mod   ! Acces to model parameters and integration scheme configuration
    use gas_mod     ! Acces to gas properties and procedures
    use ssp_mod     ! Acess to single stellar populations methods ans properties
    use config_mod  ! Acces to configurations parameters (path)

    implicit none

    public

    ! A complete stellar population is built from a set of single stellar population
    !   A ssp evolved in a set of age and metalicity bin
    !
    ! Complete stellar population
    type sp
        real(kind=rkd)           :: mass            ! Total mass of the stellar population
        real(kind=rkd)           :: mAge            ! Mass-weighted average age
        real(kind=rkd)           :: lAge            ! Luminosity-weighted average age
        real(kind=rkd)           :: mZ              ! Mass-weighted average metelicity
        real(kind=rkd)           :: lZ              ! Luminosity-weighted average metalicity
        type(ssp), allocatable   :: sfh(:, :)       ! Star Formation History
        type(status)             :: myStatus        ! Global status of the sp intput/transfer/output
    contains
        procedure  :: create => sp_create           ! Create a complete stellar population
        procedure  :: delete => sp_delete           ! Delete a stellar population structure
        procedure  :: copy => sp_copy               ! Copy a stellar population structure
        procedure  :: isCreated => sp_isCreated     ! Test if sp object is already created
        procedure  :: ststatus => sp_ststatus       !
        procedure  :: dtoptim => sp_dtoptim         ! Get the optimal time-step
        procedure  :: stevolve => sp_stevolve       !
        procedure  :: evolve => sp_evolve           ! Evolve a stellar population structure by dt
        procedure  :: iSNPower => sp_instantaneous_SNPower  ! Return the instantaneous SNP
                                                            ! The energy per time unit generated by SNs
                                                            ! i.e the SN power computed according to the current state
        procedure  :: iEjRate => sp_instantaneous_EjRate    ! Return the instantaneous gas ejecta rate produce by SNs
        !                                                   ! i.e the ejecta rate computed according to the current state
    end type sp

    ! Define sp specific parameters
    real(kind=rkd), parameter   :: sp_mass_accuracy = real(1.d-15, kind=rkd)
    real(kind=rkd), allocatable :: gas2sp(:, :)                                ! gas to sp matrix conversion, based on abundancies
    

    ! STATUS
    type(status), allocatable, target :: spStatus(:, :)
    type(status), allocatable, target :: spFinalStatus(:, :)

    ! INTERFACE OPERATOR DECLARATIONS

    interface assignment (=)  ! allows to copy a sp component by using the symbol '='
        module procedure sp_copy
    end interface assignment (=)

contains

    !
    ! SUBROUTINES
    !

    ! **********************************
    subroutine sp_init()

        ! Initialize the sp module and dependancies
        !  Read stellar population properties (mass loss rates, SN rates, spectrum)

        implicit none

        integer(kind=ikd)     :: i, j

        ! Init ssp
        call ssp_init()

        ! Init intermediate status
        if (.not. allocated(spStatus)) then
            allocate(spStatus(nAgeBins, nMetBins))
            do i = 1, nAgeBins
                do j = 1, nMetBins
                    call spStatus(i, j)%create()
                end do
            end do
        end if
        ! Init final status
        if (.not. allocated(spFinalStatus)) then
            allocate(spFinalStatus(nAgeBins, nMetBins))
            do i = 1, nAgeBins
                do j = 1, nMetBins
                    call spFinalStatus(i, j)%create()
                end do
            end do
        end if

        ! Build gas to stellar population conversion matrix
        ! Allocate the matrix
        if (.not. allocated(gas2sp)) then
            allocate(gas2sp(nMetBins, nMetBins))
            ! Init it
            do i = 1, nMetBins
                do j = 1, nMetBins
                    if (i == 1) then
                        gas2sp(i, j) = 1.
                    else
                        gas2sp(i, j) = initAbund(j)%elts(i - 1)
                    end if
                end do
            end do
        end if

    end subroutine sp_init

    ! **********************************
    subroutine sp_finalize()

        ! Delete and deallocate all sp objects

        implicit none

        integer(kind=ikd)     :: i, j

        ! Deallocate spStatus
        if (allocated(spStatus)) then
            do i = 1, nAgeBins
                do j = 1, nMetBins
                    call spStatus(i, j)%delete()
                end do
            end do
            deallocate(spStatus)
        end if
        ! Deallocate spFinalStatus
        if (allocated(spFinalStatus)) then
            do i = 1, nAgeBins
                do j = 1, nMetBins
                    call spStatus(i, j)%delete()
                end do
            end do
            deallocate(spFinalStatus)
        end if

        ! Build gas to stellar population conversion matrix
        ! Allocate the matrix
        if (allocated(gas2sp)) deallocate(gas2sp)

    end subroutine sp_finalize

    ! **********************************
    subroutine sp_create(this)

        ! Create a complete stellar population

        implicit none

        integer(kind=ikd)    :: iAge ! Age loop index
        integer(kind=ikd)    :: jMet ! Metalicity loop index

        class(sp)            :: this

        this%mass = 0.d0             ! Total mass of the stellar population
        this%mAge = 0.d0             ! Mass-weighted average age
        this%lAge = 0.d0             ! Luminosity-weighted average age
        this%mZ = 0.d0               ! Mass-weighted average metelicity
        this%lZ = 0.d0               ! Luminosity-weighted average metalicity
        call this%myStatus%create()  ! Create and init status

        allocate(this%sfh(nAgeBins, nMetBins)) ! Star Formation History
        do iAge = 1, nAgeBins
            do jMet = 1, nMetBins
                call this%sfh(iAge, jMet)%create(iAge, jMet)
            end do
        end do
    end subroutine sp_create

    ! **********************************
    subroutine sp_delete(this)

        ! Delete a complete stellar population

        implicit none

        class(sp)     :: this

        this%mass = 0.d0             ! Total mass of the stellar population
        this%mAge = 0.d0             ! Mass-weighted average age
        this%lAge = 0.d0             ! Luminosity-weighted average age
        this%mZ = 0.d0               ! Mass-weighted average metelicity
        this%lZ = 0.d0               ! Luminosity-weighted average metalicity
        call this%myStatus%delete()  !

        if (allocated(this%sfh)) deallocate(this%sfh)

    end subroutine sp_delete

    ! **********************************
    subroutine sp_copy(this, aSp)

        ! Copy in "this" the sp object aSp

        implicit none

        integer(kind=ikd)          :: i, j  ! loop indexes

        type(sp), intent(in)       :: aSp

        class(sp), intent(inout)   :: this

        if (.not. this%isCreated()) then
            ! Create g1
            call this%create()
        end if

        ! Copy fields
        this%mass = aSp%mass         ! Total mass of the stellar population
        this%mAge = aSp%mAge         ! Mass-weighted average age
        this%lAge = aSp%lAge         ! Luminosity-weighted average age
        this%mZ = aSp%mZ             ! Mass-weighted average metelicity
        this%lZ = aSp%lZ             ! Luminosity-weighted average metalicity
        this%myStatus = aSp%myStatus ! Current global status

        ! Copy star formation history
        do i = 1, nAgeBins
            do j = 1, nMetBins
                this%sfh(i, j) = aSp%sfh(i, j)
                call this%sfh(i, j)%setAsRef(aSp%sfh(i, j))
            end do
        end do

    end subroutine sp_copy

    ! **********************************
    subroutine sp_evolve(this, dt, inRate)

        ! Evolve, during dt, the current complete stellar population
        ! according to :
        ! - Internal evolution processes
        ! - A constant input rate (due to external process) "inRate"
        !
        ! No ejection from any external processes can be applied to sp
        ! In output, "outRate" is the global SN gas ejection process

        implicit none

        integer(kind=ikd)                 :: st             ! Step index of evolution scheme

        real(kind=rkd), intent(inout)     :: dt             ! The scale is evolve during dt

        type(gas), intent(in)             :: inRate         ! The (dt-)constant input rate

        type(sp), target                  :: aSp            ! The current state
        type(sp), pointer                 :: pSp            ! Pointer to the current state
        
        type(status), pointer             :: pStatus(:, :)       ! Pointer to the "current" status
        type(status), pointer             :: pFinalStatus(:, :)  ! Pointer to the "final" status

        class(sp)                         :: this           ! The current stellar population

        ! Init intermediate status with the current status
        aSp = this
        ! Pointer to the status
        pFinalStatus => spFinalStatus
        ! Pointer to the current state
        pSp => aSp
        ! Loop over integration steps
        do st = 1, nSolverStep
            !
            ! Get the current status of the sp and update "final" status
            pStatus => spStatus
            call pSp%ststatus(st, inRate, pStatus, pFinalStatus)
            !
            if (solver_isFinalStep(st)) then
                ! Switch to final status
                pStatus => spFinalStatus
            end if
            !
            ! Adaptative time-step
            dt = this%dtoptim(st, dt, pStatus)
            !
            ! Get new state
            call this%stevolve(st, dt, pStatus, pSp)
        end do
        ! Save complete evolved state
        this = aSp
        ! Delete the tmp sp structure
        call aSp%delete()

    end subroutine sp_evolve

    ! **********************************
    subroutine sp_ststatus(this, st, inRate, pStatus, pFinalStatus)

        ! Compute current status of the stellar population
        ! according to :
        ! - Internal evolution processes
        ! - A gas input rate (due to external SFR): "inRate"

        implicit none

        integer(kind=ikd), intent(in)   :: st
        integer(kind=ikd)               :: iAge, jMet

        type(gas), intent(in)           :: inRate         ! The external input rate (SFR)
        type(gas)                       :: outRate        ! SN ejecta rate
        type(gas)                       :: sspInRate      ! Input rate of the current ssp
        type(gas), allocatable          :: inRateBins(:)  ! Gas distribution into metalicity bins

        type(ssp), pointer              :: pSsp           ! Pointer to the current ssp stage
        
        type(status), pointer           :: pStatus(:, :)       ! Pointer to the "current" status
        type(status), pointer           :: pFinalStatus(:, :)  ! Pointer to the "final" status
        type(status), pointer           :: pSspStatus          ! Pointer to the "current" status of the ssp
        type(status), pointer           :: pSspFinalStatus     ! Pointer to the final status

        class(sp), target               :: this           ! The current stellar population
        !
        ! Init outRate => SN ejecta rate
        call outRate%create()
        ! Reset global status
        call this%myStatus%create()
        ! Distribute gas input stellar metalicity bins
        if (inRate%mass > 0.d0) then
            inRateBins = g2s(inRate)
        end if
        !
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! reset sspInrate
            call sspInRate%create()
            !
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                ! Get pointers
                pSspStatus => pStatus(iAge, jMet)
                pSspFinalStatus => pFinalStatus(iAge, jMet)
                pSsp => this%sfh(iAge, jMet)
                !
                ! Input rate (SFR) is only applied to the youngest ssp
                if (iAge == 1 .and. inRate%mass > 0.d0) then
                    sspInRate = sspInRate + inRateBins(jMet)
                end if
                !
                ! Update ssp status, take into account internal transfer rate
                call pSsp%ststatus(sspInRate, pSspStatus)
                !
                ! Update final status
                call pSspFinalStatus%update(st, pSspStatus)
                !
                if (pSsp%mass <= 0.d0 .and. pSspStatus%tr%mass > 0.d0) then
                    call log_message('transfert with null mass', logLevel=LOG_ERROR)
                end if
                !
                ! The transfer rate of the current ssp become an input rate
                ! for the next (older) age bin
                sspInRate = pSspStatus%tr
                !
                ! Update SN ejecta Rate
                if (pSspFinalStatus%out%isCreated()) then
                    outRate = outRate + pSspFinalStatus%out
                end if
                !
            end do ! Age loop
        end do ! Met loop
        !
        ! Set the average input rate applied
        ! Set the average SN output rate applied
        this%myStatus%in = inRate
        this%myStatus%out = outRate

    end subroutine sp_ststatus

    ! **********************************
    subroutine sp_stevolve(this, st, dt, pStatus, pSp)

        ! Apply the next step "st" of the complete integration scheme
        ! according to aStatus
        !
        ! In output
        ! - "outRate" is the global output rate produced by disruption processes on the cascade

        implicit none
    
        integer(kind=ikd), intent(in)   :: st
        integer(kind=ikd)               :: iAge, jMet

        real(kind=rkd), intent(in)      :: dt             ! The time-step
        real(kind=rkd)                  :: mass           ! Total stellar mass
        real(kind=rkd)                  :: mAge           ! mass weighted age
        real(kind=rkd)                  :: mZ             ! average metalicity

        type(status), pointer           :: pStatus(:, :)  ! Pointer to the final status of the current sp
        type(status), pointer           :: pSspStatus     ! Pointer to the current status of the ssp

        type(ssp), pointer              :: pSsp           ! Pointer to the current ssp stage

        type(sp), target                :: pSp            ! Pointer to the intermediate state

        class(sp)                       :: this           ! The current stellar population

        ! Init
        ! Get current status
        this%myStatus = pSp%myStatus
        ! Reset the new state to the current one (status is kept)
        pSp = this
        !
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                ! Get pointers
                pSspStatus => pStatus(iAge, jMet)
                pSsp => pSp%sfh(iAge, jMet)
                !
                if (pSsp%mass > 0.d0 .or. pSspStatus%in%mass > 0.d0) then
                    !
                    ! Apply the new solver step
                    call this%sfh(iAge, jMet)%stevolve(st, dt, pSspStatus, pSsp)
                end if
            end do ! Age loop
        end do ! Met loop
        !
        ! Cleaning very low mass bin
        if (solver_isFinalStep(st)) then
            ! Loop on metalicity bins
            do jMet = 1, nMetBins
                ! Loop on age bins
                do iAge = 1, nAgeBins - 1
                    !
                    ! Get pointers
                    pSsp => pSp%sfh(iAge, jMet)
                    !
                    if (pSsp%mass > 0.d0 .and. pSsp%mass < ssp_mass_accuracy .and. &
                        pSp%sfh(iAge + 1, jMet)%mass > ssp_mass_accuracy) then
                        ! Transfert to next age bin
                        pSp%sfh(iAge + 1, jMet)%mass = pSp%sfh(iAge + 1, jMet)%mass + pSsp%mass 
                        ! Reset bin
                        call pSsp%create(iAge, jMet)
                        call pSsp%setAsRef(pSp%sfh(iAge, jMet))
                    end if
                    !
                    if (pSsp%mass < 0.d0) then
                        call log_message('negative ssp mass', LOG_ERROR, &
                                 paramNames=(/'iAge                    ','jMet                    '/), &
                                 intParams=(/iAge, jMet/))
                    end if
                end do ! Age loop
            end do ! Met loop
        end if
        !
        ! Compute properties 
        mass = real(0.d0, kind=rkd)
        mAge = real(0.d0, kind=rkd)
        mZ = real(0.d0, kind=rkd)
        !
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                pSsp => pSp%sfh(iAge, jMet)
                !
                ! Compute properties
                if (pSsp%mass > 0.d0) then
                    !
                    ! Update total mass of the stellar population
                    mass = mass + pSsp%mass
                    !
                    ! Update mass weighted age
                    mAge = mAge + pSsp%mass * pSsp%avgAge
                    !
                    ! Update average metalicity
                    mZ = mZ + pSsp%mass * metBins(jMet)
                end if
            end do ! Age loop
        end do ! Met loop
        !
        ! Set total mass
        pSp%mass = mass
        !
        ! Set mass weighted age
        pSp%mAge = mAge / mass
        !
        ! Set average metalicity
        pSp%mZ = mZ / mass

    end subroutine sp_stevolve

    !
    ! FUNCTIONS
    !

    ! **********************************
    function sp_isCreated(this) result(isValid)

        ! Test the validity of a sp object

        logical     :: isValid

        class(sp)  :: this

        isValid = allocated(this%sfh)
    end function sp_isCreated

    ! **********************************
    function g2s(g) result(gasBins)

        ! Convert gas to stellar population

        implicit none

        external                       :: dgesv     ! Solver

        integer(kind=ikd)              :: i
        integer(kind=ikd)              :: rc
        integer(kind=ikd), allocatable :: pvt(:)    ! Pivot indices (list of swap operations).

        real(kind=rkd)                 :: mass
        real(kind=rkd)                 :: max, r
        real(kind=rkd), allocatable    :: B(:)      ! Mass in each bin
        real(kind=rkd), allocatable    :: A(:, :)   ! Conversion matrix

        type(gas), intent(in)          :: g         ! Gas to convert in sp
        type(gas), allocatable         :: gasBins(:)

        ! Allocate B and gasBins
        allocate(B(nMetBins))
        allocate(gasBins(nMetBins))
        !
        ! Set normalized masses
        do i = 1, nMetBins
            if (i == 1) then
                B(i) = 1.d0
            else
                B(i) = g%elts(i-1) / g%mass
            end if
        end do
        !
        ! Test null values
        if (sum(B) <= num_accuracy) then
            do i = 1, nMetBins
                call gasBins(i)%create()
            end do
            deallocate(B)
            return
        end if
        !
        ! Allocate other structures
        allocate(A(nMetBins, nMetBins))
        allocate(pvt(nMetBins))
        !
        ! Solve the system
        ! The matrix is used and modified in "dgesv", a copy is needed
        A = gas2sp
        call dgesv(nMetBins, 1, A, nMetBins, pvt, B, nMetBins, rc)
        !
        ! Clean up, very low values
        max = maxval(B)
        do i = 1, nMetBins
            r = abs(B(i)/max)
            if (r < 1.d-4 .or. B(i) < sp_mass_accuracy) B(i) = 0.d0
        end do
        ! Normalisation
        mass = sum(B)
        B = g%mass/mass * B
        mass = sum(B)
        !
        ! Convert in gas object
        do i = 1, nMetBins
            gasBins(i) = B(i) * initAbund(i)
        end do

        ! Deallocate
        deallocate(A)
        deallocate(B)
        deallocate(pvt)

    end function g2s

    ! **********************************
    function sp_dtoptim(this, st, dt, pStatus) result(adt)

        ! Return the optim time-step accoring to current status
        ! and mass

        implicit none

        integer(kind=ikd), intent(in)  :: st
        integer(kind=ikd)              :: iAge, jMet

        real(kind=rkd), intent(in)     :: dt           ! time-step
        real(kind=rkd)                 :: adt

        type(status), pointer          :: pStatus(:,:) ! Pointer to the current set of status
        type(status), pointer          :: pSspStatus   ! Pointer to a current scale status

        type(ssp), pointer             :: pSsp         ! Pointer to a ssp

        class(sp), target              :: this

        ! Run through the different ssp
        ! and deduce optimal time-step
        ! Init adaptative time-step, to current time-step
        adt = dt
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                ! Get pointers
                pSspStatus => pStatus(iAge, jMet)
                pSsp => this%sfh(iAge, jMet)
                !
                if (pSsp%mass > 0.d0) then
                    adt = pSspStatus%dtMax(st, adt, pSsp%mass)
                end if
            end do
        end do

    end function sp_dtoptim

    ! **********************************
    function sp_instantaneous_SNPower(this) result (Q)

        ! Return the instantaneous SN Power
        ! i.e the SN power computed according to the current state
        ! The SN power is the energy per time unit generates by SN explosions

        implicit none

        integer(kind=ikd)  :: iAge, jMet

        real(kind=rkd)     :: Q

        class(sp)          :: this

        ! Init snr
        Q = real(0.d0, kind=rkd)
        do jMet = 1, nMetBins
            do iAge = 1, nAgeBins
                Q = Q + this%sfh(iAge, jMet)%snp()
            end do ! Age loop
        end do ! Met loop

    end function sp_instantaneous_SNPower

    ! **********************************
    function sp_instantaneous_EjRate(this) result(rate)

        ! Return the instantaneous EJR (gas EJecta Rate)
        ! i.e the EJR computed according to the current state

        implicit none

        integer(kind=ikd)  :: iAge, jMet

        type(gas)          :: rate

        class(sp)          :: this

        ! Init rate
        call rate%create()
        do jMet = 1, nMetBins
            do iAge = 1, nAgeBins
                rate = rate + this%sfh(iAge, jMet)%mlr()
            end do ! Age loop
        end do ! Met loop

    end function sp_instantaneous_EjRate

end module sp_mod