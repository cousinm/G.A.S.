module sp_mod

    !*****************************************************************************************************************
    !
    !  OVERVIEW
    !
    ! The sp module defines all properties and procedures
    ! associated to stellar populations
    ! This structure allows to "follow" stellar evoltion process
    !    age/metalicity and build stellar population spectra
    !
    !*****************************************************************************************************************

    use parameters  ! Acces to global defintions and properties
    use model_mod   ! Acces to model parameters and integration scheme configuration
    use gas_mod     ! Acces to gas properties and procedures
    use ssp_mod     ! Acess to single stellar populations methods ans properties
    use config_mod  ! Acces to configurations parameters (path)

    implicit none

    public

    ! A complete stellar population is built from a set of single stellar population
    !   A ssp evolved in a set of age and metalicity bin
    !
    ! Complete stellar population
    type sp
        real(kind=rkd)           :: mass            ! Total mass of the stellar population
        real(kind=rkd)           :: mAge            ! Mass-weighted average age
        real(kind=rkd)           :: lAge            ! Luminosity-weighted average age
        real(kind=rkd)           :: mZ              ! Mass-weighted average metelicity
        real(kind=rkd)           :: lZ              ! Luminosity-weighted average metalicity
        type(ssp), allocatable   :: sfh(:, :)       ! Star Formation History
    contains
        procedure  :: create => sp_create           ! Create a complete stellar population
        procedure  :: delete => sp_delete           ! Delete a stellar population structure
        procedure  :: copy => sp_copy               ! Copy a stellar population structure
        procedure  :: isCreated => sp_isCreated     ! Test if sp object is already created
        procedure  :: ststatus => sp_ststatus       !
        procedure  :: dtoptim => sp_dtoptim         ! Get the optimal time-step
        procedure  :: stevolve => sp_stevolve       !
        procedure  :: evolve => sp_evolve           ! Evolve a stellar population structure by dt
        procedure  :: iSNPower => sp_instantaneous_SNPower  ! Return the instantaneous SNP
                                                            ! The energy per time unit generated by SNs
                                                            ! i.e the SN power computed according to the current state
        procedure  :: iEjRate => sp_instantaneous_EjRate    ! Return the instantaneous gas ejecta rate produce by SNs
        !                                                   ! i.e the ejecta rate computed according to the current state
    end type sp

    ! Define sp specific parameters
    real(kind=rkd), allocatable :: gas2sp(:, :)   ! gas to sp matrix conversion, based on abundancies

    ! TEMPORARY INTERMEDIATE STATUS
    ! Targets
    type(status), allocatable, target :: mySpStatus(:, :)

    ! INTERFACE OPERATOR DECLARATIONS

    interface assignment (=)  ! allows to copy a sp component by using the symbol '='
        module procedure sp_copy
    end interface assignment (=)

contains

    !
    ! SUBROUTINES
    !

    ! **********************************
    subroutine sp_init()

        ! Initialize the sp module and dependancies
        !  Read stellar population properties (mass loss rates, SN rates, spectrum)

        implicit none

        integer(kind=ikd)     :: i, j

        ! Init ssp
        call ssp_init()

        ! Init intermediate status
        if (.not. allocated(mySpStatus)) then
            allocate(mySpStatus(nAgeBins, nMetBins))
        end if

        ! Build gas to stellar population conversion matrix
        ! Allocate the matrix
        if (.not. allocated(gas2sp)) then
            allocate(gas2sp(nMetBins, nMetBins))
            ! Init it
            do i = 1, nMetBins
                do j = 1, nMetBins
                    if (i == 1) then
                        gas2sp(i, j) = 1.
                    else
                        gas2sp(i, j) = initAbund(j)%elts(i - 1)
                    end if
                end do
            end do
        end if

    end subroutine sp_init

    ! **********************************
    subroutine sp_finalize()

        ! Delete and deallocate all sp objects

        implicit none

        integer(kind=ikd)     :: i, j

        ! Deallocate spStatus
        if (allocated(mySpStatus)) then
            do i = 1, nAgeBins
                do j = 1, nMetBins
                    call mySpStatus(i, j)%delete()
                end do
            end do
            deallocate(mySpStatus)
        end if

        ! Build gas to stellar population conversion matrix
        ! Allocate the matrix
        if (allocated(gas2sp)) deallocate(gas2sp)

    end subroutine sp_finalize

    ! **********************************
    subroutine sp_create(this)

        ! Create a complete stellar population

        implicit none

        integer(kind=ikd)    :: iAge ! Age loop index
        integer(kind=ikd)    :: jMet ! Metalicity loop index

        class(sp)            :: this

        this%mass = 0.d0   ! Total mass of the stellar population
        this%mAge = 0.d0   ! Mass-weighted average age
        this%lAge = 0.d0   ! Luminosity-weighted average age
        this%mZ = 0.d0     ! Mass-weighted average metelicity
        this%lZ = 0.d0     ! Luminosity-weighted average metalicity

        allocate(this%sfh(nAgeBins, nMetBins)) ! Star Formation History
        do iAge = 1, nAgeBins
            do jMet = 1, nMetBins
                call this%sfh(iAge, jMet)%create(iAge, jMet)
            end do
        end do
    end subroutine sp_create

    ! **********************************
    subroutine sp_delete(this)

        ! Delete a complete stellar population

        implicit none

        class(sp)     :: this

        this%mass = 0.d0   ! Total mass of the stellar population
        this%mAge = 0.d0   ! Mass-weighted average age
        this%lAge = 0.d0   ! Luminosity-weighted average age
        this%mZ = 0.d0     ! Mass-weighted average metelicity
        this%lZ = 0.d0     ! Luminosity-weighted average metalicity

        if (allocated(this%sfh)) deallocate(this%sfh)

    end subroutine sp_delete

    ! **********************************
    subroutine sp_copy(this, aSp)

        ! Copy in "this" the sp object aSp

        implicit none

        integer(kind=ikd)          :: i, j  ! loop indexes

        type(sp), intent(in)       :: aSp

        class(sp), intent(inout)   :: this

        if (.not. this%isCreated()) then
            ! Create g1
            call this%create()
        end if

        ! Copy fields
        this%mass = aSp%mass   ! Total mass of the stellar population
        this%mAge = aSp%mAge   ! Mass-weighted average age
        this%lAge = aSp%lAge   ! Luminosity-weighted average age
        this%mZ = aSp%mZ       ! Mass-weighted average metelicity
        this%lZ = aSp%lZ       ! Luminosity-weighted average metalicity

        ! Copy star formation history
        do i = 1, nAgeBins
            do j = 1, nMetBins
                this%sfh(i, j) = aSp%sfh(i, j)
                call this%sfh(i, j)%setAsRef(aSp%sfh(i, j))
            end do
        end do

    end subroutine sp_copy

    ! **********************************
    subroutine sp_evolve(this, dt, inRate, outRate)

        ! Evolve, during dt, the current complete stellar population
        ! according to :
        ! - Internal evolution processes
        ! - A constant input rate (due to external process) "inRate"
        !
        ! No ejection from any external processes can be applied to sp
        ! In output, "outRate" is the global SN gas ejection process

        implicit none

        integer(kind=ikd)                 :: st             ! Step index of evolution scheme
        integer(kind=ikd)                 :: iAge, jMet

        real(kind=rkd), intent(inout)     :: dt             ! The scale is evolve during dt

        type(gas), intent(in)             :: inRate         ! The (dt-)constant input rate
        type(gas), intent(out)            :: outRate        ! Pointer to the wind/sn output rate

        type(sp), target                  :: aSp            ! The current state
        type(sp), pointer                 :: pSp            ! Pointer to the current state
        
        type(status), pointer             :: pStatus(:, :)  ! Pointer to the final status
        type(status), allocatable, target :: aStatus(:, :)  ! Current status

        class(sp)                         :: this           ! The current stellar population

        ! Init intermediate status with the current status
        aSp = this
        pSp => aSp
        ! Loop over integration steps
        do st = 1, nSolverStep
            !
            ! Get the current status of the sp and update "final" status
            pStatus => mySpStatus
            aStatus = pSp%ststatus(st, inRate, pStatus)
            !
            if (.not. solver_isFinalStep(st)) then
                ! Compute intermediate state according to current status
                pStatus => aStatus
            end if
            !
            ! Adaptative time-step
            dt = this%dtoptim(dt, pStatus)
            !
            ! Get new state
            call this%stevolve(st, dt, pStatus, outRate, pSp)
        end do
        ! Save complete evolved state
        this = aSp
        ! Delete the tmp sp structure
        call aSp%delete()
        ! Delete intermediate status
        do iAge = 1, nAgeBins
            do jMet = 1, nMetBins
                call aStatus(iAge, jMet)%delete()
            end do
        end do
        deallocate(aStatus)

    end subroutine sp_evolve

    ! **********************************
    subroutine sp_stevolve(this, st, dt, pStatus, outRate, pSp)

        ! Apply the next step "st" of the complete integration scheme
        ! according to aStatus
        !
        ! In output
        ! - "outRate" is the global output rate produced by disruption processes on the cascade

        implicit none
    
        integer(kind=ikd), intent(in)   :: st
        integer(kind=ikd)               :: iAge, jMet

        real(kind=rkd), intent(in)      :: dt             ! The time-step
        real(kind=rkd)                  :: mass           ! Total stellar mass
        real(kind=rkd)                  :: mAge           ! mass weighted age
        real(kind=rkd)                  :: mZ             ! average metalicity

        type(gas), intent(out)          :: outRate        ! Global output rate

        type(status), pointer           :: pStatus(:, :)  ! Pointer to the final status of the current sp
        type(status), pointer           :: pSspStatus     ! Pointer to the current status of the ssp

        type(ssp), pointer              :: pSsp           ! Pointer to the current ssp stage

        type(sp), target                :: pSp            ! Pointer to the intermediate state

        class(sp)                       :: this           ! The current stellar population

        ! Init
        ! outRate, global gas ejecta rate
        call outRate%create()
        ! Init the new state to the current one
        pSp = this
        ! Total mass
        mass = real(0.d0, kind=rkd)
        !
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                ! Get pointers
                pSspStatus => pStatus(iAge, jMet)
                pSsp => pSp%sfh(iAge, jMet)
                !
                if (pSsp%mass > 0.d0 .or. pSspStatus%in%mass > 0.d0) then
                    !
                    ! Apply the new solver step for the scale
                    call this%sfh(iAge, jMet)%stevolve(st, dt, pSspStatus, pSsp)
                    !
                    ! Update global ejecta rate
                    if (pSspStatus%out%isCreated()) then
                        outRate = outRate + pSspStatus%out
                    end if
                    !
                    ! Update total mass of the stellar population
                    mass = mass + pSsp%mass
                    !
                    ! Update mass weighted age
                    mAge = mAge + pSsp%mass * pSsp%avgAge
                    !
                    ! Update average metalicity
                    mZ = mZ + pSsp%mass * metBins(jMet)
                end if
            end do ! Age loop
        end do ! Met loop
        !
        ! Set total massgsh
        pSp%mass = mass
        !
        ! Set mass weighted age
        pSp%mAge = mAge / mass
        !
        ! Set average metalicity
        pSp%mZ = mZ / mass

    end subroutine sp_stevolve

    !
    ! FUNCTIONS
    !

    ! **********************************
    function sp_isCreated(this) result(isValid)

        ! Test the validity of a sp object

        logical     :: isValid

        class(sp)  :: this

        isValid = allocated(this%sfh)
    end function sp_isCreated

    ! **********************************
    function g2s(g) result(gasBins)

        ! Convert gas to stellar population

        implicit none

        external                       :: dgesv     ! Solver

        integer(kind=ikd)              :: i
        integer(kind=ikd)              :: rc
        integer(kind=ikd), allocatable :: pvt(:)    ! Pivot indices (list of swap operations).

        real(kind=rkd)                 :: mass
        real(kind=rkd)                 :: max, r
        real(kind=rkd), allocatable    :: B(:)      ! Mass in each bin
        real(kind=rkd), allocatable    :: A(:, :)   ! Conversion matrix

        type(gas), intent(in)          :: g         ! Gas to convert in sp
        type(gas), allocatable         :: gasBins(:)

        ! Allocate B and gasBins
        allocate(B(nMetBins))
        allocate(gasBins(nMetBins))
        !
        ! Set masses
        do i = 1, nMetBins
            if (i == 1) then
                B(i) = g%mass
            else
                B(i) = g%elts(i-1)
            end if
        end do
        !
        ! Test null values
        if (sum(B) <= num_accuracy) then
            do i = 1, nMetBins
                gasBins(i) = real(0.d0, kind=rkd) * initAbund(i)
            end do
            deallocate(B)
            return
        end if
        !
        ! Allocate other structures
        allocate(A(nMetBins, nMetBins))
        allocate(pvt(nMetBins))
        !
        ! Solve the system
        ! The matrix is used and modified in "dgesv", a copy is needed
        A = gas2sp
        call dgesv(nMetBins, 1, A, nMetBins, pvt, B, nMetBins, rc)
        !
        ! Clean up, very low values
        max = maxval(B)
        do i = 1, nMetBins
            r = abs(B(i)/max)
            if (r < 1.d-5 .or. B(i)<num_accuracy) B(i) = 0.d0
        end do
        ! Normalisation
        mass = sum(B)
        B = g%mass/mass * B
        !
        ! Convert in gas object
        do i = 1, nMetBins
            gasBins(i) = B(i) * initAbund(i)
        end do

        ! Deallocate
        deallocate(A)
        deallocate(B)
        deallocate(pvt)

    end function g2s

    ! **********************************
    function sp_ststatus(this, st, inRate, pStatus) result(aStatus)

        ! Compute current status of the stellar population
        ! according to :
        ! - Internal evolution processes
        ! - A gas input rate (due to external SFR): "inRate"

        implicit none

        integer(kind=ikd), intent(in)   :: st
        integer(kind=ikd)               :: iAge, jMet

        type(gas), intent(in)           :: inRate         ! The external input rate (SFR)
        type(gas)                       :: sspInRate      ! Input rate of the current ssp
        type(gas), allocatable          :: inRateBins(:)  ! Gas distribution into metalicity bins

        type(ssp), pointer              :: pSsp           ! Pointer to the current ssp stage
        
        type(status), allocatable       :: aStatus(:, :)  ! Current status
        type(status), pointer           :: pStatus(:, :)  ! Pointer to the final status of the current sp
        type(status), pointer           :: pSspStatus     ! Pointer to the current status of the ssp

        class(sp), target               :: this           ! The current stellar population
        !
        ! Allocate aStatus,
        ! this array SHOULD be deallocated at the end of the complete step evolution
        allocate(aStatus(nAgeBins, nMetBins))
        !
        ! Init sspInRate, sspOutRate and outRate
        call sspInRate%create()
        !
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                ! Get pointers
                pSspStatus => pStatus(iAge, jMet)
                pSsp => this%sfh(iAge, jMet)
                !
                ! Input rate (SFR) is only applied to the youngest ssp
                if (iAge == 1) then
                    ! Distribute gas input stellar metalicity bins
                    inRateBins = g2s(inRate)
                    sspInRate = sspInRate + inRateBins(jMet)
                end if
                !
                ! Update ssp status, take into account internal transfer rate
                ! Update the "final" status
                aStatus(iAge, jMet) = pSsp%ststatus(st, sspInRate, pSspStatus)
                !
                ! The transfer rate of the current ssp become an input rate
                ! for the next (older) age bin
                sspInRate = aStatus(iAge, jMet)%tr
                !
            end do ! Age loop
        end do ! Met loop

    end function sp_ststatus

    ! **********************************
    function sp_dtoptim(this, dt, pStatus) result(adt)

        ! Return the optim time-step accoring to current status
        ! and mass

        implicit none

        integer(kind=ikd)          :: iAge, jMet

        real(kind=rkd), intent(in) :: dt           ! time-step
        real(kind=rkd)             :: adt

        type(status), pointer      :: pStatus(:,:) ! Pointer to the current set of status
        type(status), pointer      :: pSspStatus   ! Pointer to a current scale status

        type(ssp), pointer         :: pSsp         ! Pointer to a ssp

        class(sp), target          :: this

        ! Run through the different ssp
        ! and deduce optimal time-step
        ! Init adaptative time-step, to current time-step
        adt = dt
        ! Loop on metalicity bins
        do jMet = 1, nMetBins
            ! Loop on age bins
            do iAge = 1, nAgeBins
                !
                ! Get pointers
                pSspStatus => pStatus(iAge, jMet)
                pSsp => this%sfh(iAge, jMet)
                !
                if (pSsp%mass > 0.d0) then
                    adt = pSspStatus%dtMax(adt, pSsp%mass)
                end if
            end do
        end do

    end function sp_dtoptim

    ! **********************************
    function sp_instantaneous_SNPower(this) result (Q)

        ! Return the instantaneous SN Power
        ! i.e the SN power computed according to the current state
        ! The SN power is the energy per time unit generates by SN explosions

        implicit none

        integer(kind=ikd)  :: iAge, jMet

        real(kind=rkd)     :: Q
        real(kind=rkd)     :: mbin

        class(sp)          :: this

        ! Init snr
        Q = real(0.d0, kind=rkd)
        do jMet = 1, nMetBins
            do iAge = 1, nAgeBins
                mbin = this%sfh(iAge, jMet)%mass
                if (mbin > 0.d0) then
                    Q = Q + mbin * SNR(iAge, jMet)*Esn   ! [CU]
                end if
            end do ! Age loop
        end do ! Met loop

    end function sp_instantaneous_SNPower

    ! **********************************
    function sp_instantaneous_EjRate(this) result(rate)

        ! Return the instantaneous EJR (gas EJecta Rate)
        ! i.e the EJR computed according to the current state

        implicit none

        integer(kind=ikd)  :: iAge, jMet

        real(kind=rkd)     :: mbin

        type(gas)          :: rate

        class(sp)          :: this

        ! Init rate
        call rate%create()
        do jMet = 1, nMetBins
            do iAge = 1, nAgeBins
                mbin = this%sfh(iAge, jMet)%mass
                if (mbin > 0.d0) then
                    rate = rate + mbin * MLR(iAge, jMet)  ! [CU]
                end if
            end do ! Age loop
        end do ! Met loop

    end function sp_instantaneous_EjRate

end module sp_mod